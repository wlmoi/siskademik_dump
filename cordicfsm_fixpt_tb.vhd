-- -------------------------------------------------------------
-- 
-- File Name: D:\Matlab\W_exports\cordicfsm\codegen\cordicfsm\hdlsrc\cordicfsm_fixpt_tb.vhd
-- Created: 2024-12-22 20:00:21
-- 
-- Generated by MATLAB 24.2, MATLAB Coder 24.2 and HDL Coder 24.2
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: cordicfsm_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.cordicfsm_fixpt_pac.ALL;
USE work.cordicfsm_fixpt_tb_pac.ALL;

ENTITY cordicfsm_fixpt_tb IS
END cordicfsm_fixpt_tb;


ARCHITECTURE rtl OF cordicfsm_fixpt_tb IS

  -- Component Declarations
  COMPONENT cordicfsm_fixpt
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          cordic_on                       :   IN    std_logic;  -- ufix1
          x_in                            :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
          y_in                            :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
          ce_out                          :   OUT   std_logic;
          zz                              :   OUT   std_logic;
          r_cordic                        :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14_En5
          p_cordic                        :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14_En8
          x_out                           :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14_En4
          y_out                           :   OUT   std_logic_vector(13 DOWNTO 0)  -- sfix14_En36
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : cordicfsm_fixpt
    USE ENTITY work.cordicfsm_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset_x                          : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL y_out_done                       : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL y_out_done_enb                   : std_logic;  -- ufix1
  SIGNAL zz_addr                          : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL y_out_lastAddr                   : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL x_out_done                       : std_logic;  -- ufix1
  SIGNAL x_out_done_enb                   : std_logic;  -- ufix1
  SIGNAL x_out_lastAddr                   : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL p_cordic_done                    : std_logic;  -- ufix1
  SIGNAL p_cordic_done_enb                : std_logic;  -- ufix1
  SIGNAL p_cordic_lastAddr                : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL r_cordic_done                    : std_logic;  -- ufix1
  SIGNAL r_cordic_done_enb                : std_logic;  -- ufix1
  SIGNAL r_cordic_lastAddr                : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL zz_done                          : std_logic;  -- ufix1
  SIGNAL zz_done_enb                      : std_logic;  -- ufix1
  SIGNAL zz_active                        : std_logic;  -- ufix1
  SIGNAL Cordic_on_addr                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL y_in_addr_delay_1                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL tb_enb                           : std_logic;
  SIGNAL rawData_y_in                     : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL holdData_y_in                    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL y_in_offset                      : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL y_in                             : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL y_in_1                           : std_logic_vector(8 DOWNTO 0);  -- ufix9
  SIGNAL x_in_addr_delay_1                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL rawData_x_in                     : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL holdData_x_in                    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL x_in_offset                      : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL x_in                             : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL x_in_1                           : std_logic_vector(8 DOWNTO 0);  -- ufix9
  SIGNAL Cordic_on_active                 : std_logic;  -- ufix1
  SIGNAL Cordic_on_enb                    : std_logic;  -- ufix1
  SIGNAL Cordic_on_addr_delay_1           : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL rawData_cordic_on                : std_logic;  -- ufix1
  SIGNAL holdData_cordic_on               : std_logic;  -- ufix1
  SIGNAL cordic_on_offset                 : std_logic;  -- ufix1
  SIGNAL cordic_on_1                      : std_logic;  -- ufix1
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL ce_out                           : std_logic;
  SIGNAL zz                               : std_logic;
  SIGNAL r_cordic                         : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL p_cordic                         : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL x_out                            : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL y_out                            : std_logic_vector(13 DOWNTO 0);  -- ufix14
  SIGNAL zz_enb                           : std_logic;  -- ufix1
  SIGNAL zz_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL constone                         : std_logic;  -- ufix1
  SIGNAL zz_chkenb                        : std_logic;  -- ufix1
  SIGNAL zz_chkdata                       : std_logic;  -- ufix1
  SIGNAL zz_addr_delay_1                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL zz_expected                      : std_logic;
  SIGNAL zz_ref                           : std_logic;
  SIGNAL zz_testFailure                   : std_logic;  -- ufix1
  SIGNAL constone_1                       : std_logic;  -- ufix1
  SIGNAL r_cordic_chkenb                  : std_logic;  -- ufix1
  SIGNAL r_cordic_chkdata                 : std_logic;  -- ufix1
  SIGNAL r_cordic_addr_delay_1            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL r_cordic_unsigned                : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL r_cordic_expected                : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL r_cordic_ref                     : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL r_cordic_testFailure             : std_logic;  -- ufix1
  SIGNAL constone_2                       : std_logic;  -- ufix1
  SIGNAL p_cordic_chkenb                  : std_logic;  -- ufix1
  SIGNAL p_cordic_chkdata                 : std_logic;  -- ufix1
  SIGNAL p_cordic_addr_delay_1            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL p_cordic_unsigned                : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL p_cordic_expected                : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL p_cordic_ref                     : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL p_cordic_testFailure             : std_logic;  -- ufix1
  SIGNAL constone_3                       : std_logic;  -- ufix1
  SIGNAL x_out_chkenb                     : std_logic;  -- ufix1
  SIGNAL x_out_chkdata                    : std_logic;  -- ufix1
  SIGNAL x_out_addr_delay_1               : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL x_out_unsigned                   : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL x_out_expected                   : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL x_out_ref                        : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL x_out_testFailure                : std_logic;  -- ufix1
  SIGNAL constone_4                       : std_logic;  -- ufix1
  SIGNAL y_out_chkenb                     : std_logic;  -- ufix1
  SIGNAL y_out_chkdata                    : std_logic;  -- ufix1
  SIGNAL y_out_signed                     : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL y_out_expected_1                 : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL y_out_ref                        : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL y_out_testFailure                : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_cordicfsm_fixpt : cordicfsm_fixpt
    PORT MAP( clk => clk,
              reset_x => reset_x,
              clk_enable => enb,
              cordic_on => cordic_on_1,  -- ufix1
              x_in => x_in_1,  -- ufix9
              y_in => y_in_1,  -- ufix9
              ce_out => ce_out,
              zz => zz,
              r_cordic => r_cordic,  -- ufix14_En5
              p_cordic => p_cordic,  -- ufix14_En8
              x_out => x_out,  -- ufix14_En4
              y_out => y_out  -- sfix14_En36
              );

  y_out_done_enb <= y_out_done AND rdEnb;

  
  y_out_lastAddr <= '1' WHEN zz_addr >= to_unsigned(16#24#, 6) ELSE
      '0';

  y_out_done <= y_out_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      check5_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y_out_done_enb = '1' THEN
        check5_done <= y_out_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  x_out_done_enb <= x_out_done AND rdEnb;

  
  x_out_lastAddr <= '1' WHEN zz_addr >= to_unsigned(16#24#, 6) ELSE
      '0';

  x_out_done <= x_out_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      check4_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF x_out_done_enb = '1' THEN
        check4_done <= x_out_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  p_cordic_done_enb <= p_cordic_done AND rdEnb;

  
  p_cordic_lastAddr <= '1' WHEN zz_addr >= to_unsigned(16#24#, 6) ELSE
      '0';

  p_cordic_done <= p_cordic_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF p_cordic_done_enb = '1' THEN
        check3_done <= p_cordic_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  r_cordic_done_enb <= r_cordic_done AND rdEnb;

  
  r_cordic_lastAddr <= '1' WHEN zz_addr >= to_unsigned(16#24#, 6) ELSE
      '0';

  r_cordic_done <= r_cordic_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF r_cordic_done_enb = '1' THEN
        check2_done <= r_cordic_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  zz_done_enb <= zz_done AND rdEnb;

  
  zz_active <= '1' WHEN zz_addr /= to_unsigned(16#24#, 6) ELSE
      '0';

  y_in_addr_delay_1 <= Cordic_on_addr AFTER 1 ns;

  -- Data source for y_in
  y_in_fileread: PROCESS (y_in_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "y_in.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(11 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_y_in <= unsigned(read_data(8 DOWNTO 0));
  END PROCESS y_in_fileread;

  -- holdData reg for y_in
  stimuli_y_in_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      holdData_y_in <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_y_in <= rawData_y_in;
    END IF;
  END PROCESS stimuli_y_in_process;

  stimuli_y_in_1: PROCESS (rawData_y_in, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      y_in_offset <= holdData_y_in;
    ELSE
      y_in_offset <= rawData_y_in;
    END IF;
  END PROCESS stimuli_y_in_1;

  y_in <= y_in_offset AFTER 2 ns;

  y_in_1 <= std_logic_vector(y_in);

  x_in_addr_delay_1 <= Cordic_on_addr AFTER 1 ns;

  -- Data source for x_in
  x_in_fileread: PROCESS (x_in_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "x_in.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(11 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_x_in <= unsigned(read_data(8 DOWNTO 0));
  END PROCESS x_in_fileread;

  -- holdData reg for x_in
  stimuli_x_in_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      holdData_x_in <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_x_in <= rawData_x_in;
    END IF;
  END PROCESS stimuli_x_in_process;

  stimuli_x_in_1: PROCESS (rawData_x_in, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      x_in_offset <= holdData_x_in;
    ELSE
      x_in_offset <= rawData_x_in;
    END IF;
  END PROCESS stimuli_x_in_1;

  x_in <= x_in_offset AFTER 2 ns;

  x_in_1 <= std_logic_vector(x_in);

  
  Cordic_on_active <= '1' WHEN Cordic_on_addr /= to_unsigned(16#24#, 6) ELSE
      '0';

  Cordic_on_enb <= Cordic_on_active AND (rdEnb AND tb_enb);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 36
  Cordic_on_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      Cordic_on_addr <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF Cordic_on_enb = '1' THEN
        IF Cordic_on_addr >= to_unsigned(16#24#, 6) THEN 
          Cordic_on_addr <= to_unsigned(16#00#, 6);
        ELSE 
          Cordic_on_addr <= Cordic_on_addr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS Cordic_on_process;


  Cordic_on_addr_delay_1 <= Cordic_on_addr AFTER 1 ns;

  -- Data source for cordic_on
  cordic_on_fileread: PROCESS (Cordic_on_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "cordic_on.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    rawData_cordic_on <= read_data;
  END PROCESS cordic_on_fileread;

  -- holdData reg for Cordic_on
  stimuli_Cordic_on_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      holdData_cordic_on <= 'X';
    ELSIF clk'event AND clk = '1' THEN
      holdData_cordic_on <= rawData_cordic_on;
    END IF;
  END PROCESS stimuli_Cordic_on_process;

  stimuli_Cordic_on_1: PROCESS (rawData_cordic_on, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      cordic_on_offset <= holdData_cordic_on;
    ELSE
      cordic_on_offset <= rawData_cordic_on;
    END IF;
  END PROCESS stimuli_Cordic_on_1;

  cordic_on_1 <= cordic_on_offset AFTER 2 ns;

  snkDonen <=  NOT snkDone;

  resetn <=  NOT reset_x;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  enb <= rdEnb AFTER 2 ns;

  reset_x_gen: PROCESS 
  BEGIN
    reset_x <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset_x <= '0';
    WAIT;
  END PROCESS reset_x_gen;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  zz_enb <= ce_out AND zz_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 36
  Z_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      zz_addr <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF zz_enb = '1' THEN
        IF zz_addr >= to_unsigned(16#24#, 6) THEN 
          zz_addr <= to_unsigned(16#00#, 6);
        ELSE 
          zz_addr <= zz_addr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS Z_process;


  
  zz_lastAddr <= '1' WHEN zz_addr >= to_unsigned(16#24#, 6) ELSE
      '0';

  zz_done <= zz_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF zz_done_enb = '1' THEN
        check1_done <= zz_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done)));

  constone <= '1';

  -- Delay to implement IgnoreDataChecking
  zz_IgnoreDataChecking_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      zz_chkenb <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' THEN
        zz_chkenb <= constone;
      END IF;
    END IF;
  END PROCESS zz_IgnoreDataChecking_process;

  zz_chkdata <= ce_out AND zz_chkenb;

  zz_addr_delay_1 <= zz_addr AFTER 1 ns;

  -- Data source for zz_expected
  zz_expected_fileread: PROCESS (zz_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "zz_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    zz_expected <= read_data;
  END PROCESS zz_expected_fileread;

  zz_ref <= zz_expected;

  zz_checker: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      zz_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF zz_chkdata = '1' AND zz /= zz_ref THEN
        zz_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in zz: Expected " & to_hex(zz_ref) & (" Actual " & to_hex(zz))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS zz_checker;

  constone_1 <= '1';

  -- Delay to implement IgnoreDataChecking
  r_cordic_IgnoreDataChecking_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      r_cordic_chkenb <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' THEN
        r_cordic_chkenb <= constone_1;
      END IF;
    END IF;
  END PROCESS r_cordic_IgnoreDataChecking_process;

  r_cordic_chkdata <= ce_out AND r_cordic_chkenb;

  r_cordic_addr_delay_1 <= zz_addr AFTER 1 ns;

  r_cordic_unsigned <= unsigned(r_cordic);

  -- Data source for r_cordic_expected
  r_cordic_expected_fileread: PROCESS (r_cordic_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "r_cordic_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    r_cordic_expected <= unsigned(read_data(13 DOWNTO 0));
  END PROCESS r_cordic_expected_fileread;

  r_cordic_ref <= r_cordic_expected;

  r_cordic_unsigned_checker: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      r_cordic_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF r_cordic_chkdata = '1' AND r_cordic_unsigned /= r_cordic_ref THEN
        r_cordic_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in r_cordic_unsigned: Expected " & to_hex(r_cordic_ref) & (" Actual " & to_hex(r_cordic_unsigned))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS r_cordic_unsigned_checker;

  constone_2 <= '1';

  -- Delay to implement IgnoreDataChecking
  p_cordic_IgnoreDataChecking_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      p_cordic_chkenb <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' THEN
        p_cordic_chkenb <= constone_2;
      END IF;
    END IF;
  END PROCESS p_cordic_IgnoreDataChecking_process;

  p_cordic_chkdata <= ce_out AND p_cordic_chkenb;

  p_cordic_addr_delay_1 <= zz_addr AFTER 1 ns;

  p_cordic_unsigned <= unsigned(p_cordic);

  -- Data source for p_cordic_expected
  p_cordic_expected_fileread: PROCESS (p_cordic_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "p_cordic_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    p_cordic_expected <= unsigned(read_data(13 DOWNTO 0));
  END PROCESS p_cordic_expected_fileread;

  p_cordic_ref <= p_cordic_expected;

  p_cordic_unsigned_checker: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      p_cordic_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF p_cordic_chkdata = '1' AND p_cordic_unsigned /= p_cordic_ref THEN
        p_cordic_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in p_cordic_unsigned: Expected " & to_hex(p_cordic_ref) & (" Actual " & to_hex(p_cordic_unsigned))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS p_cordic_unsigned_checker;

  constone_3 <= '1';

  -- Delay to implement IgnoreDataChecking
  x_out_IgnoreDataChecking_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      x_out_chkenb <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' THEN
        x_out_chkenb <= constone_3;
      END IF;
    END IF;
  END PROCESS x_out_IgnoreDataChecking_process;

  x_out_chkdata <= ce_out AND x_out_chkenb;

  x_out_addr_delay_1 <= zz_addr AFTER 1 ns;

  x_out_unsigned <= unsigned(x_out);

  -- Data source for x_out_expected
  x_out_expected_fileread: PROCESS (x_out_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "x_out_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    x_out_expected <= unsigned(read_data(13 DOWNTO 0));
  END PROCESS x_out_expected_fileread;

  x_out_ref <= x_out_expected;

  x_out_unsigned_checker: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      x_out_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF x_out_chkdata = '1' AND x_out_unsigned /= x_out_ref THEN
        x_out_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in x_out_unsigned: Expected " & to_hex(x_out_ref) & (" Actual " & to_hex(x_out_unsigned))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS x_out_unsigned_checker;

  constone_4 <= '1';

  -- Delay to implement IgnoreDataChecking
  y_out_IgnoreDataChecking_process: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      y_out_chkenb <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' THEN
        y_out_chkenb <= constone_4;
      END IF;
    END IF;
  END PROCESS y_out_IgnoreDataChecking_process;

  y_out_chkdata <= ce_out AND y_out_chkenb;

  y_out_signed <= signed(y_out);

  -- Data source for y_out_expected
  y_out_expected_1 <= to_signed(16#0000#, 14);

  y_out_ref <= y_out_expected_1;

  y_out_signed_checker: PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      y_out_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF y_out_chkdata = '1' AND y_out_signed /= y_out_ref THEN
        y_out_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in y_out_signed: Expected " & to_hex(y_out_ref) & (" Actual " & to_hex(y_out_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS y_out_signed_checker;

  testFailure <= y_out_testFailure OR (x_out_testFailure OR (p_cordic_testFailure OR (zz_testFailure OR r_cordic_testFailure)));

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

