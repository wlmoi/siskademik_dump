-- -------------------------------------------------------------
-- 
-- File Name: D:\Matlab\W_exports\cordicfsm\codegen\cordicfsm\hdlsrc\cordicfsm_fixpt.vhd
-- Created: 2024-12-22 19:58:12
-- 
-- Generated by MATLAB 24.2, MATLAB Coder 24.2 and HDL Coder 24.2
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- zz                            ce_out        1
-- r_cordic                      ce_out        1
-- p_cordic                      ce_out        1
-- x_out                         ce_out        1
-- y_out                         ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: cordicfsm_fixpt
-- Source Path: cordicfsm_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.cordicfsm_fixpt_pac.ALL;

ENTITY cordicfsm_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        cordic_on                         :   IN    std_logic;  -- ufix1
        x_in                              :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        y_in                              :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        ce_out                            :   OUT   std_logic;
        zz                                :   OUT   std_logic;
        r_cordic                          :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14_En5
        p_cordic                          :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14_En8
        x_out                             :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14_En4
        y_out                             :   OUT   std_logic_vector(13 DOWNTO 0)  -- sfix14_En36
        );
END cordicfsm_fixpt;


ARCHITECTURE rtl OF cordicfsm_fixpt IS

  -- Constants
  CONSTANT tmp_76                         : vector_of_unsigned14(0 TO 31) := 
    (to_unsigned(16#2D00#, 14), to_unsigned(16#1A90#, 14), to_unsigned(16#0E09#, 14), to_unsigned(16#0720#, 
      14), to_unsigned(16#0393#, 14), to_unsigned(16#01CA#, 14), to_unsigned(16#00E5#, 14), 
      to_unsigned(16#0072#, 14), to_unsigned(16#0039#, 14), to_unsigned(16#001C#, 14), to_unsigned(16#000E#, 
      14), to_unsigned(16#0007#, 14), to_unsigned(16#0003#, 14), to_unsigned(16#0001#, 14), 
      to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 
      14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), 
      to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 
      14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), 
      to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 
      14)); -- ufix14 [32]
  CONSTANT tmp_78                         : vector_of_unsigned14(0 TO 31) := 
    (to_unsigned(16#2D00#, 14), to_unsigned(16#1A90#, 14), to_unsigned(16#0E09#, 14), to_unsigned(16#0720#, 
      14), to_unsigned(16#0393#, 14), to_unsigned(16#01CA#, 14), to_unsigned(16#00E5#, 14), 
      to_unsigned(16#0072#, 14), to_unsigned(16#0039#, 14), to_unsigned(16#001C#, 14), to_unsigned(16#000E#, 
      14), to_unsigned(16#0007#, 14), to_unsigned(16#0003#, 14), to_unsigned(16#0001#, 14), 
      to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 
      14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), 
      to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 
      14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), 
      to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 14), to_unsigned(16#0000#, 
      14)); -- ufix14 [32]

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Cordic_on_1                      : std_logic;  -- ufix1
  SIGNAL curr_state                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL s_s                              : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iter_Cordic                      : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL curr_state_1                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL curr_state_2                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL s_s_1                            : std_logic;
  SIGNAL curr_state_3                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL curr_state_4                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp                              : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL iter_Cordic_1                    : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL tmp_1                            : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL tmp_2                            : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL tmp_3                            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL s_s_2                            : std_logic;
  SIGNAL tmp_4                            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL s_s_3                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_5                            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL tmp_6                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_8                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_10                           : std_logic;
  SIGNAL tmp_11                           : std_logic;
  SIGNAL tmp_12                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_13                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL y_in_unsigned                    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL tmp_14                           : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL tmp_15                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_16                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL x_in_unsigned                    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL tmp_17                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL y_Cordic                         : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL c_c_9                            : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL tmp_18                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL x_Cordic                         : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_19                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_20                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_21                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL c_c_13                           : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL tmp_22                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_23                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_24                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_25                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL c_c_17                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_26                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_27                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_28                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_29                           : signed(13 DOWNTO 0);  -- sfix14_En5
  SIGNAL c_c_21                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_30                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_31                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_32                           : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL tmp_33                           : signed(13 DOWNTO 0);  -- sfix14_En5
  SIGNAL s_s_4                            : std_logic;
  SIGNAL tmp_34                           : signed(13 DOWNTO 0);  -- sfix14_En5
  SIGNAL tmp_35                           : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL tmp_36                           : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL tmp_38                           : signed(13 DOWNTO 0);  -- sfix14_En4
  SIGNAL tmp_39                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_40                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_42                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL s_s_5                            : unsigned(13 DOWNTO 0);  -- ufix14_En14
  SIGNAL tmp_43                           : unsigned(27 DOWNTO 0);  -- ufix28_En18
  SIGNAL tmp_44                           : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL r_Cordic_1                       : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL tmp_45                           : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL tmp_46                           : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL tmp_48                           : unsigned(13 DOWNTO 0);  -- ufix14_En5
  SIGNAL s_s_6                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL s_s_7                            : std_logic;
  SIGNAL tmp_49                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL s_s_8                            : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL tmp_50                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL s_s_9                            : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL s_s_10                           : std_logic;
  SIGNAL s_s_11                           : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL tmp_51                           : unsigned(15 DOWNTO 0);  -- ufix16_En8
  SIGNAL s_s_12                           : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL tmp_52                           : unsigned(15 DOWNTO 0);  -- ufix16_En8
  SIGNAL z_Cordic                         : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL stateControl_4                   : std_logic;
  SIGNAL stateControl_5                   : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL z_Cordic_1                       : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL tmp_53                           : unsigned(15 DOWNTO 0);  -- ufix16_En8
  SIGNAL tmp_54                           : unsigned(15 DOWNTO 0);  -- ufix16_En8
  SIGNAL tmp_55                           : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL tmp_56                           : unsigned(15 DOWNTO 0);  -- ufix16_En8
  SIGNAL tmp_57                           : unsigned(15 DOWNTO 0);  -- ufix16_En8
  SIGNAL tmp_58                           : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL tmp_59                           : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL tmp_60                           : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL tmp_62                           : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL tmp_63                           : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL phi_Cordic                       : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL tmp_64                           : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL tmp_65                           : unsigned(13 DOWNTO 0);  -- ufix14_En8
  SIGNAL x_out_Cordic                     : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_67                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_68                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_70                           : unsigned(13 DOWNTO 0);  -- ufix14_En4
  SIGNAL tmp_71                           : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL y_out_Cordic                     : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL tmp_72                           : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL tmp_73                           : signed(13 DOWNTO 0);  -- sfix14_En36
  SIGNAL tmp_75                           : signed(13 DOWNTO 0);  -- sfix14_En36

BEGIN
  Cordic_on_1 <= cordic_on;

  curr_state <= to_unsigned(16#0#, 2);

  -- Menandakan selesai
  s_s <= to_unsigned(16#01#, 7);

  iter_Cordic <= to_unsigned(16#00#, 6);

  enb <= clk_enable;

  curr_state_1 <= to_unsigned(16#3#, 2);

  curr_state_2 <= to_unsigned(16#2#, 2);

  s_s_1 <= Cordic_on_1;

  curr_state_3 <= to_unsigned(16#1#, 2);

  
  tmp <= curr_state_4 WHEN s_s_1 = '0' ELSE
      curr_state_3;

  tmp_1 <= resize(iter_Cordic_1, 7);

  tmp_2 <= tmp_1 + s_s;

  tmp_3 <= tmp_2(5 DOWNTO 0);

  
  tmp_4 <= iter_Cordic_1 WHEN s_s_2 = '0' ELSE
      tmp_3;

  p92_output : PROCESS (iter_Cordic, iter_Cordic_1, s_s_3, tmp_4)
    VARIABLE tmp1 : unsigned(5 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp1 := iter_Cordic_1;
      WHEN "00000000000000000000000000000001" =>
        tmp1 := iter_Cordic;
      WHEN "00000000000000000000000000000010" =>
        tmp1 := tmp_4;
      WHEN "00000000000000000000000000000011" =>
        tmp1 := iter_Cordic_1;
      WHEN OTHERS => 
        tmp1 := iter_Cordic_1;
    END CASE;
    tmp_5 <= tmp1;
  END PROCESS p92_output;


  iter_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      iter_Cordic_1 <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        iter_Cordic_1 <= tmp_5;
      END IF;
    END IF;
  END PROCESS iter_Cordic_reg_process;


  
  s_s_2 <= '1' WHEN iter_Cordic_1 < to_unsigned(16#20#, 6) ELSE
      '0';

  
  tmp_6 <= curr_state_1 WHEN s_s_2 = '0' ELSE
      curr_state_4;

  p83_output : PROCESS (curr_state, curr_state_2, curr_state_4, s_s_3, tmp, tmp_6)
    VARIABLE tmp7 : unsigned(1 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp7 := tmp;
      WHEN "00000000000000000000000000000001" =>
        tmp7 := curr_state_2;
      WHEN "00000000000000000000000000000010" =>
        tmp7 := tmp_6;
      WHEN "00000000000000000000000000000011" =>
        tmp7 := curr_state;
      WHEN OTHERS => 
        tmp7 := curr_state_4;
    END CASE;
    tmp_8 <= tmp7;
  END PROCESS p83_output;


  -- Logika mesin keadaan Moore
  curr_state_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      curr_state_4 <= to_unsigned(16#0#, 2);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        curr_state_4 <= tmp_8;
      END IF;
    END IF;
  END PROCESS curr_state_reg_process;


  s_s_3 <= signed(resize(curr_state_4, 32));

  -- Fungsi inisialisasi CORDIC
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  --                                                                          %
  --          Generated by MATLAB 24.2 and Fixed-Point Designer 24.2          %
  --                                                                          %
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- Mesin Keadaan Moore dengan State IDLE, START, CALCULATE, dan DONE
  -- Definisi state
  -- Menggunakan persistent untuk menyimpan status antar siklus
  -- Nilai keluaran awal
  p84_output : PROCESS (s_s_3)
    VARIABLE tmp9 : std_logic;
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp9 := '0';
      WHEN "00000000000000000000000000000001" =>
        tmp9 := '0';
      WHEN "00000000000000000000000000000010" =>
        tmp9 := '0';
      WHEN "00000000000000000000000000000011" =>
        tmp9 := '1';
      WHEN OTHERS => 
        tmp9 := '0';
    END CASE;
    tmp_10 <= tmp9;
  END PROCESS p84_output;


  delayMatch_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      tmp_11 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_11 <= tmp_10;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  tmp_12 <= signed(resize(iter_Cordic_1, 32));

  tmp_13 <= signed(resize(iter_Cordic_1, 32));

  y_in_unsigned <= unsigned(y_in);

  tmp_14 <= signed(resize(y_in_unsigned & '0' & '0' & '0' & '0', 14));

  tmp_15 <= signed(resize(iter_Cordic_1, 32));

  tmp_16 <= signed(resize(iter_Cordic_1, 32));

  x_in_unsigned <= unsigned(x_in);

  tmp_17 <= resize(x_in_unsigned & '0' & '0' & '0' & '0', 14);

  c_c_9 <= SHIFT_RIGHT(y_Cordic, to_integer(tmp_16));

  tmp_18 <= resize(c_c_9, 16);

  tmp_19 <= signed(resize(x_Cordic, 16));

  tmp_20 <= tmp_19 + tmp_18;

  tmp_21 <= unsigned(tmp_20(13 DOWNTO 0));

  c_c_13 <= SHIFT_RIGHT(y_Cordic, to_integer(tmp_15));

  tmp_22 <= resize(c_c_13, 16);

  tmp_23 <= signed(resize(x_Cordic, 16));

  tmp_24 <= tmp_23 - tmp_22;

  tmp_25 <= unsigned(tmp_24(13 DOWNTO 0));

  c_c_17 <= SHIFT_RIGHT(x_Cordic, to_integer(tmp_13));

  tmp_26 <= signed(resize(c_c_17, 16));

  tmp_27 <= resize(y_Cordic, 16);

  tmp_28 <= tmp_27 - tmp_26;

  tmp_29 <= tmp_28(12 DOWNTO 0) & '0';

  c_c_21 <= SHIFT_RIGHT(x_Cordic, to_integer(tmp_12));

  tmp_30 <= signed(resize(c_c_21, 16));

  tmp_31 <= resize(y_Cordic, 16);

  tmp_32 <= tmp_31 + tmp_30;

  tmp_33 <= tmp_32(12 DOWNTO 0) & '0';

  
  tmp_34 <= tmp_33 WHEN s_s_4 = '0' ELSE
      tmp_29;

  tmp_35 <= resize(tmp_34(13 DOWNTO 1), 14);

  
  tmp_36 <= y_Cordic WHEN s_s_2 = '0' ELSE
      tmp_35;

  p88_output : PROCESS (s_s_3, tmp_14, tmp_36, y_Cordic)
    VARIABLE tmp37 : signed(13 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp37 := y_Cordic;
      WHEN "00000000000000000000000000000001" =>
        tmp37 := tmp_14;
      WHEN "00000000000000000000000000000010" =>
        tmp37 := tmp_36;
      WHEN "00000000000000000000000000000011" =>
        tmp37 := y_Cordic;
      WHEN OTHERS => 
        tmp37 := y_Cordic;
    END CASE;
    tmp_38 <= tmp37;
  END PROCESS p88_output;


  -- Fungsi iterasi CORDIC
  y_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      y_Cordic <= to_signed(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        y_Cordic <= tmp_38;
      END IF;
    END IF;
  END PROCESS y_Cordic_reg_process;


  
  s_s_4 <= '1' WHEN y_Cordic >= to_signed(16#0000#, 14) ELSE
      '0';

  
  tmp_39 <= tmp_25 WHEN s_s_4 = '0' ELSE
      tmp_21;

  
  tmp_40 <= x_Cordic WHEN s_s_2 = '0' ELSE
      tmp_39;

  p90_output : PROCESS (s_s_3, tmp_17, tmp_40, x_Cordic)
    VARIABLE tmp41 : unsigned(13 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp41 := x_Cordic;
      WHEN "00000000000000000000000000000001" =>
        tmp41 := tmp_17;
      WHEN "00000000000000000000000000000010" =>
        tmp41 := tmp_40;
      WHEN "00000000000000000000000000000011" =>
        tmp41 := x_Cordic;
      WHEN OTHERS => 
        tmp41 := x_Cordic;
    END CASE;
    tmp_42 <= tmp41;
  END PROCESS p90_output;


  x_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      x_Cordic <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        x_Cordic <= tmp_42;
      END IF;
    END IF;
  END PROCESS x_Cordic_reg_process;


  -- Radius hasil (dengan gain tetap)
  s_s_5 <= to_unsigned(16#26DD#, 14);

  tmp_43 <= x_Cordic * s_s_5;

  tmp_44 <= tmp_43(26 DOWNTO 13);

  
  tmp_45 <= tmp_44 WHEN s_s_2 = '0' ELSE
      r_Cordic_1;

  r_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      r_Cordic_1 <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        r_Cordic_1 <= tmp_46;
      END IF;
    END IF;
  END PROCESS r_Cordic_reg_process;


  p100_output : PROCESS (r_Cordic_1, s_s_3, tmp_45)
    VARIABLE tmp47 : unsigned(13 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp47 := r_Cordic_1;
      WHEN "00000000000000000000000000000001" =>
        tmp47 := r_Cordic_1;
      WHEN "00000000000000000000000000000010" =>
        tmp47 := tmp_45;
      WHEN "00000000000000000000000000000011" =>
        tmp47 := r_Cordic_1;
      WHEN OTHERS => 
        tmp47 := r_Cordic_1;
    END CASE;
    tmp_46 <= tmp47;
  END PROCESS p100_output;


  delayMatch_1_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      tmp_48 <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_48 <= tmp_46;
      END IF;
    END IF;
  END PROCESS delayMatch_1_process;


  r_cordic <= std_logic_vector(tmp_48);

  reduced_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      s_s_6 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_s_6 <= s_s_3;
      END IF;
    END IF;
  END PROCESS reduced_process;


  stateControl_1 <= '1';

  delayMatch_2_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      stateControl_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_2 <= stateControl_1;
      END IF;
    END IF;
  END PROCESS delayMatch_2_process;


  enb_gated <= stateControl_2 AND clk_enable;

  reduced_1_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      s_s_7 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_s_7 <= s_s_2;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  tmp_49 <= signed(resize(iter_Cordic_1, 32));

  s_s_8 <= tmp_76(to_integer(tmp_49));

  tmp_50 <= signed(resize(iter_Cordic_1, 32));

  s_s_9 <= tmp_78(to_integer(tmp_50));

  delayMatch_3_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      s_s_10 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_s_10 <= s_s_4;
      END IF;
    END IF;
  END PROCESS delayMatch_3_process;


  tmp_lut_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_s_11 <= s_s_8;
      END IF;
    END IF;
  END PROCESS tmp_lut_reg_process;


  tmp_51 <= resize(s_s_11, 16);

  tmp_lut_reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_s_12 <= s_s_9;
      END IF;
    END IF;
  END PROCESS tmp_lut_reg_1_process;


  tmp_52 <= resize(s_s_12, 16);

  z_Cordic <= to_unsigned(16#0000#, 14);

  stateControl_4 <= '1';

  delayMatch_4_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      stateControl_5 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_5 <= stateControl_4;
      END IF;
    END IF;
  END PROCESS delayMatch_4_process;


  enb_gated_1 <= stateControl_5 AND clk_enable;

  tmp_53 <= resize(z_Cordic_1 & '0', 16);

  tmp_54 <= tmp_53 + tmp_52;

  tmp_55 <= tmp_54(14 DOWNTO 1);

  tmp_56 <= resize(z_Cordic_1 & '0', 16);

  tmp_57 <= tmp_56 - tmp_51;

  tmp_58 <= tmp_57(14 DOWNTO 1);

  
  tmp_59 <= tmp_58 WHEN s_s_10 = '0' ELSE
      tmp_55;

  
  tmp_60 <= z_Cordic_1 WHEN s_s_7 = '0' ELSE
      tmp_59;

  p86_output : PROCESS (s_s_6, tmp_60, z_Cordic, z_Cordic_1)
    VARIABLE tmp61 : unsigned(13 DOWNTO 0);
  BEGIN
    CASE s_s_6 IS
      WHEN "00000000000000000000000000000000" =>
        tmp61 := z_Cordic_1;
      WHEN "00000000000000000000000000000001" =>
        tmp61 := z_Cordic;
      WHEN "00000000000000000000000000000010" =>
        tmp61 := tmp_60;
      WHEN "00000000000000000000000000000011" =>
        tmp61 := z_Cordic_1;
      WHEN OTHERS => 
        tmp61 := z_Cordic_1;
    END CASE;
    tmp_62 <= tmp61;
  END PROCESS p86_output;


  -- Sudut akhir
  z_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      z_Cordic_1 <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_1 = '1' THEN
        z_Cordic_1 <= tmp_62;
      END IF;
    END IF;
  END PROCESS z_Cordic_reg_process;


  tmp_63 <= z_Cordic_1(12 DOWNTO 0) & '0';

  
  tmp_64 <= tmp_63 WHEN s_s_7 = '0' ELSE
      phi_Cordic;

  phi_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      phi_Cordic <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        phi_Cordic <= tmp_65;
      END IF;
    END IF;
  END PROCESS phi_Cordic_reg_process;


  p98_output : PROCESS (phi_Cordic, s_s_6, tmp_64)
    VARIABLE tmp66 : unsigned(13 DOWNTO 0);
  BEGIN
    CASE s_s_6 IS
      WHEN "00000000000000000000000000000000" =>
        tmp66 := phi_Cordic;
      WHEN "00000000000000000000000000000001" =>
        tmp66 := phi_Cordic;
      WHEN "00000000000000000000000000000010" =>
        tmp66 := tmp_64;
      WHEN "00000000000000000000000000000011" =>
        tmp66 := phi_Cordic;
      WHEN OTHERS => 
        tmp66 := phi_Cordic;
    END CASE;
    tmp_65 <= tmp66;
  END PROCESS p98_output;


  p_cordic <= std_logic_vector(tmp_65);

  
  tmp_67 <= x_Cordic WHEN s_s_2 = '0' ELSE
      x_out_Cordic;

  x_out_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      x_out_Cordic <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        x_out_Cordic <= tmp_68;
      END IF;
    END IF;
  END PROCESS x_out_Cordic_reg_process;


  p96_output : PROCESS (s_s_3, tmp_67, x_out_Cordic)
    VARIABLE tmp69 : unsigned(13 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp69 := x_out_Cordic;
      WHEN "00000000000000000000000000000001" =>
        tmp69 := x_out_Cordic;
      WHEN "00000000000000000000000000000010" =>
        tmp69 := tmp_67;
      WHEN "00000000000000000000000000000011" =>
        tmp69 := x_out_Cordic;
      WHEN OTHERS => 
        tmp69 := x_out_Cordic;
    END CASE;
    tmp_68 <= tmp69;
  END PROCESS p96_output;


  delayMatch_5_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      tmp_70 <= to_unsigned(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_70 <= tmp_68;
      END IF;
    END IF;
  END PROCESS delayMatch_5_process;


  x_out <= std_logic_vector(tmp_70);

  tmp_71 <= to_signed(16#0000#, 14);

  
  tmp_72 <= tmp_71 WHEN s_s_2 = '0' ELSE
      y_out_Cordic;

  -- Update keluaran
  y_out_Cordic_reg_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      y_out_Cordic <= to_signed(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        y_out_Cordic <= tmp_73;
      END IF;
    END IF;
  END PROCESS y_out_Cordic_reg_process;


  p94_output : PROCESS (s_s_3, tmp_72, y_out_Cordic)
    VARIABLE tmp74 : signed(13 DOWNTO 0);
  BEGIN
    CASE s_s_3 IS
      WHEN "00000000000000000000000000000000" =>
        tmp74 := y_out_Cordic;
      WHEN "00000000000000000000000000000001" =>
        tmp74 := y_out_Cordic;
      WHEN "00000000000000000000000000000010" =>
        tmp74 := tmp_72;
      WHEN "00000000000000000000000000000011" =>
        tmp74 := y_out_Cordic;
      WHEN OTHERS => 
        tmp74 := y_out_Cordic;
    END CASE;
    tmp_73 <= tmp74;
  END PROCESS p94_output;


  delayMatch_6_process : PROCESS (clk, reset_x)
  BEGIN
    IF reset_x = '1' THEN
      tmp_75 <= to_signed(16#0000#, 14);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_75 <= tmp_73;
      END IF;
    END IF;
  END PROCESS delayMatch_6_process;


  y_out <= std_logic_vector(tmp_75);

  ce_out <= clk_enable;

  zz <= tmp_11;

END rtl;

