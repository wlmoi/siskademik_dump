%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 24.2 and Fixed-Point Designer 24.2          %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
function [Z, r_cordic, p_cordic, x_out, y_out] = cordicfsm_fixpt(Cordic_on, x_in, y_in)
    % Mesin Keadaan Moore dengan State IDLE, START, CALCULATE, dan DONE

    % Definisi state
    fm = get_fimath();

    IDLE = fi(0, 0, 1, 0, fm);
    START = fi(1, 0, 1, 0, fm);
    CALCULATE = fi(2, 0, 2, 0, fm);
    DONE = fi(3, 0, 2, 0, fm);

    % Menggunakan persistent untuk menyimpan status antar siklus
    persistent curr_state x_Cordic y_Cordic z_Cordic r_Cordic phi_Cordic iter_Cordic x_out_Cordic y_out_Cordic;
    if isempty(curr_state)
        curr_state = fi(IDLE, 0, 2, 0, fm);
        x_Cordic = fi(0, 0, 14, 4, fm); y_Cordic = fi(0, 1, 14, 4, fm); z_Cordic = fi(0, 0, 14, 7, fm);
        r_Cordic = fi(0, 0, 14, 5, fm); phi_Cordic = fi(0, 0, 14, 8, fm);
        iter_Cordic = fi(0, 0, 6, 0, fm);
        x_out_Cordic = fi(0, 0, 14, 4, fm); y_out_Cordic = fi(0, 1, 14, 36, fm);
    end

    % Nilai keluaran awal
    Z = false;
    r_cordic = fi(r_Cordic, 0, 14, 5, fm);
    p_cordic = fi(phi_Cordic, 0, 14, 8, fm);
    x_out = fi(x_out_Cordic, 0, 14, 4, fm);
    y_out = fi(y_out_Cordic, 1, 14, 36, fm);

    % Logika mesin keadaan Moore
    switch curr_state
        case IDLE
            if Cordic_on
                curr_state(:) = START;
            end

        case START
            iter_Cordic(:) = 0;
            [x_Cordic(:), y_Cordic(:), z_Cordic(:)] = Cordic_init(x_in, y_in);
            curr_state(:) = CALCULATE;

        case CALCULATE
            if iter_Cordic < fi(32, 0, 6, 0, fm)
                [x_Cordic(:), y_Cordic(:), z_Cordic(:)] = Cordic_step(x_Cordic, y_Cordic, z_Cordic, iter_Cordic);
                iter_Cordic(:) = iter_Cordic + fi(1, 0, 1, 0, fm);
            else
                r_Cordic(:) = x_Cordic * fi(0.60725287, 0, 14, 14, fm); % Radius hasil (dengan gain tetap)
                phi_Cordic(:) = z_Cordic; % Sudut akhir
                x_out_Cordic(:) = x_Cordic;
                y_out_Cordic(:) = y_Cordic;
                curr_state(:) = DONE;
            end

        case DONE
            Z(:) = true; % Menandakan selesai
            curr_state(:) = IDLE;
    end

    % Update keluaran
    r_cordic(:) = r_Cordic;
    p_cordic(:) = phi_Cordic;
    x_out(:) = x_out_Cordic;
    y_out(:) = y_out_Cordic;
end

% Fungsi inisialisasi CORDIC
function [x_Cordic, y_Cordic, z_Cordic] = Cordic_init(x_in, y_in)
    fm = get_fimath();

    if x_in >= fi(0, 0, 1, 0, fm)
        x_Cordic = fi(x_in, 0, 9, 0, fm);
        y_Cordic = fi(y_in, 0, 9, 0, fm);
        z_Cordic = fi(0, 0, 1, 0, fm);
    elseif y_in >= fi(0, 0, 1, 0, fm)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        x_Cordic = fi(y_in, 0, 9, 0, fm);
        y_Cordic = fi(fi_uminus(x_in), 0, 9, 0, fm);
        z_Cordic = fi(90, 0, 1, 0, fm);
        %F2F: End block
    else
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        x_Cordic = fi(fi_uminus(y_in), 0, 9, 0, fm);
        y_Cordic = fi(x_in, 0, 9, 0, fm);
        z_Cordic = fi(-90, 0, 1, 0, fm);
        %F2F: End block
    end
end

% Fungsi iterasi CORDIC
function [x_next_Cordic, y_next_Cordic, z_next_Cordic] = Cordic_step(x_Cordic, y_Cordic, z_Cordic, iter_Cordic)
    fm = get_fimath();

    Cordic_angles = fi([ ...
        45.0000, 26.5651, 14.0362, 7.1250, 3.5763, ...
        1.7899, 0.8952, 0.4476, 0.2238, 0.1119, ...
        0.0560, 0.0280, 0.0140, 0.0070, 0.0035, ...
        0.0017, 0.0009, 0.0004, 0.0002, 0.0001, ...
        0.00005, 0.00002, 0.00001, 0.000005, ...
        0.000002, 0.000001, 0.0000005, 0.0000002, ...
        0.0000001, 0.00000005, 0.00000002, 0.00000001 ...
    ], 0, 14, 8, fm);

    if y_Cordic >= fi(0, 0, 1, 0, fm)
        x_next_Cordic = fi(x_Cordic + bitsra(y_Cordic, fi_toint(iter_Cordic)), 0, 14, 4, fm);
        y_next_Cordic = fi(y_Cordic - bitsra(x_Cordic, fi_toint(iter_Cordic)), 1, 14, 5, fm);
        z_next_Cordic = fi(z_Cordic + Cordic_angles(iter_Cordic+fi(1, 0, 1, 0, fm)), 0, 14, 7, fm);
    else
        x_next_Cordic = fi(x_Cordic - bitsra(y_Cordic, fi_toint(iter_Cordic)), 0, 14, 4, fm);
        y_next_Cordic = fi(y_Cordic + bitsra(x_Cordic, fi_toint(iter_Cordic)), 1, 14, 5, fm);
        z_next_Cordic = fi(z_Cordic - Cordic_angles(iter_Cordic+fi(1, 0, 1, 0, fm)), 0, 14, 7, fm);
    end
end



function y = fi_toint(u)
    coder.inline( 'always' );
    if isfi( u )
        nt = numerictype( u );
        s = nt.SignednessBool;
        wl = nt.WordLength;
        y = int32( fi( u, s, wl, 0, hdlfimath ) );
    else
        y = int32( u );
    end
end


function y = fi_uminus(a)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = -fi( a, new_nt, fimath( a ) );
    else
        y = -a;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
